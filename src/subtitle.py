"""Subtitle generation module"""

import subprocess
from pathlib import Path
from typing import Dict, Any, List
from .transcribe import Segment


def generate_subtitle(
    segments: List[Segment],
    output_path: Path,
    config: Dict[str, Any]
) -> None:
    """
    Generate subtitle file

    Args:
        segments: List of subtitle segments
        output_path: Output file path
        config: Configuration dictionary
    """
    if not segments:
        raise ValueError("No subtitle content to generate")

    format_type = config.get('output', {}).get('format', 'srt')
    bilingual = config.get('output', {}).get('bilingual', False)

    if format_type == 'srt':
        _generate_srt(segments, output_path, bilingual)
    elif format_type == 'ass':
        _generate_ass(segments, output_path, bilingual, config)
    elif format_type == 'vtt':
        _generate_vtt(segments, output_path, bilingual)
    else:
        raise ValueError(f"Unsupported subtitle format: {format_type}")


def _format_time_srt(seconds: float) -> str:
    """Format time for SRT format (HH:MM:SS,mmm)"""
    if seconds < 0:
        seconds = 0
    # Use round to avoid floating point errors
    total_ms = round(seconds * 1000)
    hours, remainder = divmod(total_ms, 3600000)
    minutes, remainder = divmod(remainder, 60000)
    secs, millis = divmod(remainder, 1000)
    return f"{hours:02d}:{minutes:02d}:{secs:02d},{millis:03d}"


def _format_time_vtt(seconds: float) -> str:
    """Format time for VTT format (HH:MM:SS.mmm)"""
    if seconds < 0:
        seconds = 0
    total_ms = round(seconds * 1000)
    hours, remainder = divmod(total_ms, 3600000)
    minutes, remainder = divmod(remainder, 60000)
    secs, millis = divmod(remainder, 1000)
    return f"{hours:02d}:{minutes:02d}:{secs:02d}.{millis:03d}"


def _format_time_ass(seconds: float) -> str:
    """Format time for ASS format (H:MM:SS.cc)"""
    if seconds < 0:
        seconds = 0
    total_cs = round(seconds * 100)
    hours, remainder = divmod(total_cs, 360000)
    minutes, remainder = divmod(remainder, 6000)
    secs, centis = divmod(remainder, 100)
    return f"{hours}:{minutes:02d}:{secs:02d}.{centis:02d}"


def _escape_ass_text(text: str) -> str:
    """Escape special characters in ASS format"""
    # Handle backslash first
    text = text.replace('\\', '\\\\')
    # Curly braces are used for style tags, need escaping
    text = text.replace('{', '\\{')
    text = text.replace('}', '\\}')
    # ASS uses \N for newline
    text = text.replace('\n', '\\N')
    return text


def _generate_srt(segments: List[Segment], output_path: Path, bilingual: bool) -> None:
    """Generate SRT format subtitle"""
    lines = []
    subtitle_index = 0  # Independent counter to ensure sequential numbering

    for seg in segments:
        # Skip empty subtitles
        content = seg.translated or seg.text
        if not content.strip():
            continue

        subtitle_index += 1
        lines.append(str(subtitle_index))
        lines.append(f"{_format_time_srt(seg.start)} --> {_format_time_srt(seg.end)}")

        if bilingual and seg.text and seg.translated:
            # Bilingual: translation on top, original below
            lines.append(seg.translated)
            lines.append(seg.text)
        else:
            lines.append(content)

        lines.append("")  # Empty line separator

    output_path.parent.mkdir(parents=True, exist_ok=True)
    output_path.write_text("\n".join(lines), encoding='utf-8')


def _generate_vtt(segments: List[Segment], output_path: Path, bilingual: bool) -> None:
    """Generate WebVTT format subtitle"""
    lines = ["WEBVTT", ""]

    for seg in segments:
        content = seg.translated or seg.text
        if not content.strip():
            continue

        lines.append(f"{_format_time_vtt(seg.start)} --> {_format_time_vtt(seg.end)}")

        if bilingual and seg.text and seg.translated:
            lines.append(seg.translated)
            lines.append(seg.text)
        else:
            lines.append(content)

        lines.append("")

    output_path.parent.mkdir(parents=True, exist_ok=True)
    output_path.write_text("\n".join(lines), encoding='utf-8')


def _generate_ass(
    segments: List[Segment],
    output_path: Path,
    bilingual: bool,
    config: Dict[str, Any]
) -> None:
    """Generate ASS format subtitle (with styles)"""
    # ASS header
    header = """[Script Info]
Title: Generated by SubGen
ScriptType: v4.00+
PlayResX: 1920
PlayResY: 1080
WrapStyle: 0

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,Arial,60,&H00FFFFFF,&H000000FF,&H00000000,&H80000000,0,0,0,0,100,100,0,0,1,3,1,2,10,10,30,1
Style: Secondary,Arial,45,&H00AAAAAA,&H000000FF,&H00000000,&H80000000,0,0,0,0,100,100,0,0,1,2,1,2,10,10,80,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
"""

    lines = [header]

    for seg in segments:
        content = seg.translated or seg.text
        if not content.strip():
            continue

        start = _format_time_ass(seg.start)
        end = _format_time_ass(seg.end)

        if bilingual and seg.text and seg.translated:
            # Bilingual: two lines
            trans_escaped = _escape_ass_text(seg.translated)
            orig_escaped = _escape_ass_text(seg.text)
            lines.append(f"Dialogue: 0,{start},{end},Default,,0,0,0,,{trans_escaped}")
            lines.append(f"Dialogue: 0,{start},{end},Secondary,,0,0,0,,{orig_escaped}")
        else:
            escaped = _escape_ass_text(content)
            lines.append(f"Dialogue: 0,{start},{end},Default,,0,0,0,,{escaped}")

    output_path.parent.mkdir(parents=True, exist_ok=True)
    output_path.write_text("\n".join(lines), encoding='utf-8')


def _escape_ffmpeg_filter_path(path: str) -> str:
    r"""
    Escape path for FFmpeg filter
    FFmpeg filter requires escaping: \ ' : [ ]
    """
    # Convert backslash to forward slash first
    path = path.replace('\\', '/')
    # Escape FFmpeg filter special characters
    for char in ["'", ":", "[", "]"]:
        path = path.replace(char, '\\' + char)
    return path


def embed_subtitle(
    video_path: Path,
    subtitle_path: Path,
    output_path: Path,
    config: Dict[str, Any]
) -> None:
    """
    Burn subtitles into video (hardcoded subtitles)

    Args:
        video_path: Original video path
        subtitle_path: Subtitle file path
        output_path: Output video path
        config: Configuration dictionary
    """
    subtitle_path_escaped = _escape_ffmpeg_filter_path(str(subtitle_path.absolute()))

    cmd = [
        'ffmpeg',
        '-i', str(video_path),
        '-vf', f"subtitles='{subtitle_path_escaped}'",
        '-c:a', 'copy',
        '-y',
        '-loglevel', 'error',
        str(output_path)
    ]

    result = subprocess.run(cmd, capture_output=True, text=True)

    if result.returncode != 0:
        raise RuntimeError(f"Subtitle embedding failed: {result.stderr}")


def add_subtitle_track(
    video_path: Path,
    subtitle_path: Path,
    output_path: Path,
    language: str = "chi"
) -> None:
    """
    Add subtitle as a track to video (soft subtitles)

    Args:
        video_path: Original video path
        subtitle_path: Subtitle file path
        output_path: Output video path
        language: Subtitle language code (ISO 639-2)
    """
    cmd = [
        'ffmpeg',
        '-i', str(video_path),
        '-i', str(subtitle_path),
        '-c', 'copy',
        '-c:s', 'mov_text',
        '-metadata:s:s:0', f'language={language}',
        '-y',
        '-loglevel', 'error',
        str(output_path)
    ]

    result = subprocess.run(cmd, capture_output=True, text=True)

    if result.returncode != 0:
        raise RuntimeError(f"Failed to add subtitle track: {result.stderr}")
