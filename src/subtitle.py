"""字幕生成模块"""

import subprocess
from pathlib import Path
from typing import Dict, Any, List
from .transcribe import Segment


def generate_subtitle(
    segments: List[Segment],
    output_path: Path,
    config: Dict[str, Any]
) -> None:
    """
    生成字幕文件
    
    Args:
        segments: 字幕片段列表
        output_path: 输出文件路径
        config: 配置字典
    """
    if not segments:
        raise ValueError("没有字幕内容可生成")
    
    format_type = config.get('output', {}).get('format', 'srt')
    bilingual = config.get('output', {}).get('bilingual', False)
    
    if format_type == 'srt':
        _generate_srt(segments, output_path, bilingual)
    elif format_type == 'ass':
        _generate_ass(segments, output_path, bilingual, config)
    elif format_type == 'vtt':
        _generate_vtt(segments, output_path, bilingual)
    else:
        raise ValueError(f"不支持的字幕格式: {format_type}")


def _format_time_srt(seconds: float) -> str:
    """格式化时间为 SRT 格式 (HH:MM:SS,mmm)"""
    if seconds < 0:
        seconds = 0
    # 使用 round 避免浮点误差
    total_ms = round(seconds * 1000)
    hours, remainder = divmod(total_ms, 3600000)
    minutes, remainder = divmod(remainder, 60000)
    secs, millis = divmod(remainder, 1000)
    return f"{hours:02d}:{minutes:02d}:{secs:02d},{millis:03d}"


def _format_time_vtt(seconds: float) -> str:
    """格式化时间为 VTT 格式 (HH:MM:SS.mmm)"""
    if seconds < 0:
        seconds = 0
    total_ms = round(seconds * 1000)
    hours, remainder = divmod(total_ms, 3600000)
    minutes, remainder = divmod(remainder, 60000)
    secs, millis = divmod(remainder, 1000)
    return f"{hours:02d}:{minutes:02d}:{secs:02d}.{millis:03d}"


def _format_time_ass(seconds: float) -> str:
    """格式化时间为 ASS 格式 (H:MM:SS.cc)"""
    if seconds < 0:
        seconds = 0
    total_cs = round(seconds * 100)
    hours, remainder = divmod(total_cs, 360000)
    minutes, remainder = divmod(remainder, 6000)
    secs, centis = divmod(remainder, 100)
    return f"{hours}:{minutes:02d}:{secs:02d}.{centis:02d}"


def _escape_ass_text(text: str) -> str:
    """转义 ASS 格式中的特殊字符"""
    # 先处理反斜杠
    text = text.replace('\\', '\\\\')
    # 花括号用于样式标签，需要转义
    text = text.replace('{', '\\{')
    text = text.replace('}', '\\}')
    # ASS 中换行使用 \N
    text = text.replace('\n', '\\N')
    return text


def _generate_srt(segments: List[Segment], output_path: Path, bilingual: bool) -> None:
    """生成 SRT 格式字幕"""
    lines = []
    subtitle_index = 0  # 独立计数器，确保编号连续
    
    for seg in segments:
        # 跳过空字幕
        content = seg.translated or seg.text
        if not content.strip():
            continue
        
        subtitle_index += 1
        lines.append(str(subtitle_index))
        lines.append(f"{_format_time_srt(seg.start)} --> {_format_time_srt(seg.end)}")
        
        if bilingual and seg.text and seg.translated:
            # 双语: 译文在上，原文在下
            lines.append(seg.translated)
            lines.append(seg.text)
        else:
            lines.append(content)
        
        lines.append("")  # 空行分隔
    
    output_path.parent.mkdir(parents=True, exist_ok=True)
    output_path.write_text("\n".join(lines), encoding='utf-8')


def _generate_vtt(segments: List[Segment], output_path: Path, bilingual: bool) -> None:
    """生成 WebVTT 格式字幕"""
    lines = ["WEBVTT", ""]
    
    for seg in segments:
        content = seg.translated or seg.text
        if not content.strip():
            continue
        
        lines.append(f"{_format_time_vtt(seg.start)} --> {_format_time_vtt(seg.end)}")
        
        if bilingual and seg.text and seg.translated:
            lines.append(seg.translated)
            lines.append(seg.text)
        else:
            lines.append(content)
        
        lines.append("")
    
    output_path.parent.mkdir(parents=True, exist_ok=True)
    output_path.write_text("\n".join(lines), encoding='utf-8')


def _generate_ass(
    segments: List[Segment],
    output_path: Path,
    bilingual: bool,
    config: Dict[str, Any]
) -> None:
    """生成 ASS 格式字幕（支持样式）"""
    # ASS 头部
    header = """[Script Info]
Title: Generated by SubGen
ScriptType: v4.00+
PlayResX: 1920
PlayResY: 1080
WrapStyle: 0

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,Arial,60,&H00FFFFFF,&H000000FF,&H00000000,&H80000000,0,0,0,0,100,100,0,0,1,3,1,2,10,10,30,1
Style: Secondary,Arial,45,&H00AAAAAA,&H000000FF,&H00000000,&H80000000,0,0,0,0,100,100,0,0,1,2,1,2,10,10,80,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
"""
    
    lines = [header]
    
    for seg in segments:
        content = seg.translated or seg.text
        if not content.strip():
            continue
        
        start = _format_time_ass(seg.start)
        end = _format_time_ass(seg.end)
        
        if bilingual and seg.text and seg.translated:
            # 双语: 两行
            trans_escaped = _escape_ass_text(seg.translated)
            orig_escaped = _escape_ass_text(seg.text)
            lines.append(f"Dialogue: 0,{start},{end},Default,,0,0,0,,{trans_escaped}")
            lines.append(f"Dialogue: 0,{start},{end},Secondary,,0,0,0,,{orig_escaped}")
        else:
            escaped = _escape_ass_text(content)
            lines.append(f"Dialogue: 0,{start},{end},Default,,0,0,0,,{escaped}")
    
    output_path.parent.mkdir(parents=True, exist_ok=True)
    output_path.write_text("\n".join(lines), encoding='utf-8')


def _escape_ffmpeg_filter_path(path: str) -> str:
    r"""
    转义 FFmpeg filter 中的路径
    FFmpeg filter 需要转义: \ ' : [ ]
    """
    # 先转义反斜杠
    path = path.replace('\\', '/')
    # 转义 FFmpeg filter 特殊字符
    for char in ["'", ":", "[", "]"]:
        path = path.replace(char, '\\' + char)
    return path


def embed_subtitle(
    video_path: Path,
    subtitle_path: Path,
    output_path: Path,
    config: Dict[str, Any]
) -> None:
    """
    将字幕烧录进视频（硬字幕）
    
    Args:
        video_path: 原视频路径
        subtitle_path: 字幕文件路径
        output_path: 输出视频路径
        config: 配置字典
    """
    subtitle_path_escaped = _escape_ffmpeg_filter_path(str(subtitle_path.absolute()))
    
    cmd = [
        'ffmpeg',
        '-i', str(video_path),
        '-vf', f"subtitles='{subtitle_path_escaped}'",
        '-c:a', 'copy',
        '-y',
        '-loglevel', 'error',
        str(output_path)
    ]
    
    result = subprocess.run(cmd, capture_output=True, text=True)
    
    if result.returncode != 0:
        raise RuntimeError(f"字幕烧录失败: {result.stderr}")


def add_subtitle_track(
    video_path: Path,
    subtitle_path: Path,
    output_path: Path,
    language: str = "chi"
) -> None:
    """
    将字幕作为轨道添加到视频（软字幕）
    
    Args:
        video_path: 原视频路径
        subtitle_path: 字幕文件路径
        output_path: 输出视频路径
        language: 字幕语言代码 (ISO 639-2)
    """
    cmd = [
        'ffmpeg',
        '-i', str(video_path),
        '-i', str(subtitle_path),
        '-c', 'copy',
        '-c:s', 'mov_text',
        '-metadata:s:s:0', f'language={language}',
        '-y',
        '-loglevel', 'error',
        str(output_path)
    ]
    
    result = subprocess.run(cmd, capture_output=True, text=True)
    
    if result.returncode != 0:
        raise RuntimeError(f"添加字幕轨道失败: {result.stderr}")
