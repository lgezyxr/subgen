"""Subtitle generation module"""

import subprocess
from pathlib import Path
from typing import Dict, Any, List, Optional
from .transcribe import Segment
from .styles import StyleProfile, load_style, hex_to_ass_color


def generate_subtitle(
    segments: List[Segment],
    output_path: Path,
    config: Dict[str, Any],
    style: Optional[StyleProfile] = None,
) -> None:
    """
    Generate subtitle file

    Args:
        segments: List of subtitle segments
        output_path: Output file path
        config: Configuration dictionary
    """
    if not segments:
        raise ValueError("No subtitle content to generate")

    format_type = config.get('output', {}).get('format', 'srt')
    bilingual = config.get('output', {}).get('bilingual', False)

    # Resolve style for ASS
    if style is None:
        resolved_style = load_style(config)
    else:
        resolved_style = style

    if format_type == 'srt':
        _generate_srt(segments, output_path, bilingual)
    elif format_type == 'ass':
        _generate_ass(segments, output_path, bilingual, config, resolved_style)
    elif format_type == 'vtt':
        _generate_vtt(segments, output_path, bilingual)
    else:
        raise ValueError(f"Unsupported subtitle format: {format_type}")


def _format_time_srt(seconds: float) -> str:
    """Format time for SRT format (HH:MM:SS,mmm)"""
    if seconds < 0:
        seconds = 0
    # Use round to avoid floating point errors
    total_ms = round(seconds * 1000)
    hours, remainder = divmod(total_ms, 3600000)
    minutes, remainder = divmod(remainder, 60000)
    secs, millis = divmod(remainder, 1000)
    return f"{hours:02d}:{minutes:02d}:{secs:02d},{millis:03d}"


def _format_time_vtt(seconds: float) -> str:
    """Format time for VTT format (HH:MM:SS.mmm)"""
    if seconds < 0:
        seconds = 0
    total_ms = round(seconds * 1000)
    hours, remainder = divmod(total_ms, 3600000)
    minutes, remainder = divmod(remainder, 60000)
    secs, millis = divmod(remainder, 1000)
    return f"{hours:02d}:{minutes:02d}:{secs:02d}.{millis:03d}"


def _format_time_ass(seconds: float) -> str:
    """Format time for ASS format (H:MM:SS.cc)"""
    if seconds < 0:
        seconds = 0
    total_cs = round(seconds * 100)
    hours, remainder = divmod(total_cs, 360000)
    minutes, remainder = divmod(remainder, 6000)
    secs, centis = divmod(remainder, 100)
    return f"{hours}:{minutes:02d}:{secs:02d}.{centis:02d}"


def _escape_ass_text(text: str) -> str:
    """Escape special characters in ASS format"""
    # Handle backslash first
    text = text.replace('\\', '\\\\')
    # Curly braces are used for style tags, need escaping
    text = text.replace('{', '\\{')
    text = text.replace('}', '\\}')
    # ASS uses \N for newline
    text = text.replace('\n', '\\N')
    return text


def _generate_srt(segments: List[Segment], output_path: Path, bilingual: bool) -> None:
    """Generate SRT format subtitle"""
    lines = []
    subtitle_index = 0  # Independent counter to ensure sequential numbering

    for seg in segments:
        # Skip empty subtitles
        content = seg.translated or seg.text
        if not content.strip():
            continue

        subtitle_index += 1
        lines.append(str(subtitle_index))
        lines.append(f"{_format_time_srt(seg.start)} --> {_format_time_srt(seg.end)}")

        if bilingual and seg.text and seg.translated:
            # Bilingual: translation on top, original below
            lines.append(seg.translated)
            lines.append(seg.text)
        else:
            lines.append(content)

        lines.append("")  # Empty line separator

    output_path.parent.mkdir(parents=True, exist_ok=True)
    output_path.write_text("\n".join(lines), encoding='utf-8')


def _generate_vtt(segments: List[Segment], output_path: Path, bilingual: bool) -> None:
    """Generate WebVTT format subtitle"""
    lines = ["WEBVTT", ""]

    for seg in segments:
        content = seg.translated or seg.text
        if not content.strip():
            continue

        lines.append(f"{_format_time_vtt(seg.start)} --> {_format_time_vtt(seg.end)}")

        if bilingual and seg.text and seg.translated:
            lines.append(seg.translated)
            lines.append(seg.text)
        else:
            lines.append(content)

        lines.append("")

    output_path.parent.mkdir(parents=True, exist_ok=True)
    output_path.write_text("\n".join(lines), encoding='utf-8')


def _generate_ass(
    segments: List[Segment],
    output_path: Path,
    bilingual: bool,
    config: Dict[str, Any],
    style: Optional[StyleProfile] = None,
) -> None:
    """Generate ASS format subtitle (with styles)"""
    if style is not None:
        header = style.to_ass_header()
    else:
        header = """[Script Info]
Title: Generated by SubGen
ScriptType: v4.00+
PlayResX: 1920
PlayResY: 1080
WrapStyle: 0

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,Arial,60,&H00FFFFFF,&H000000FF,&H00000000,&H80000000,0,0,0,0,100,100,0,0,1,3,1,2,10,10,30,1
Style: Secondary,Arial,45,&H00AAAAAA,&H000000FF,&H00000000,&H80000000,0,0,0,0,100,100,0,0,1,2,1,2,10,10,80,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text"""

    lines = [header]

    for seg in segments:
        content = seg.translated or seg.text
        if not content.strip():
            continue

        start = _format_time_ass(seg.start)
        end = _format_time_ass(seg.end)

        if bilingual and seg.text and seg.translated:
            trans_escaped = _escape_ass_text(seg.translated)
            orig_escaped = _escape_ass_text(seg.text)
            if style is not None:
                # Single Dialogue with \N and inline style override for secondary
                sec = style.secondary
                sec_color = hex_to_ass_color(sec.color)
                inline = f"{{\\fn{sec.font}\\fs{sec.size}\\c{sec_color}}}"
                lines.append(
                    f"Dialogue: 0,{start},{end},Default,,0,0,0,,{trans_escaped}\\N{inline}{orig_escaped}"
                )
            else:
                # Legacy: two separate Dialogue lines
                lines.append(f"Dialogue: 0,{start},{end},Default,,0,0,0,,{trans_escaped}")
                lines.append(f"Dialogue: 0,{start},{end},Secondary,,0,0,0,,{orig_escaped}")
        else:
            escaped = _escape_ass_text(content)
            lines.append(f"Dialogue: 0,{start},{end},Default,,0,0,0,,{escaped}")

    output_path.parent.mkdir(parents=True, exist_ok=True)
    output_path.write_text("\n".join(lines), encoding='utf-8')


def _escape_ffmpeg_filter_path(path: str) -> str:
    r"""
    Escape path for FFmpeg filter
    FFmpeg filter requires escaping: \ ' : [ ]
    """
    # Convert backslash to forward slash first
    path = path.replace('\\', '/')
    # Escape FFmpeg filter special characters
    for char in ["'", ":", "[", "]"]:
        path = path.replace(char, '\\' + char)
    return path


def embed_subtitle(
    video_path: Path,
    subtitle_path: Path,
    output_path: Path,
    config: Dict[str, Any]
) -> None:
    """
    Burn subtitles into video (hardcoded subtitles)

    Args:
        video_path: Original video path
        subtitle_path: Subtitle file path
        output_path: Output video path
        config: Configuration dictionary
    """
    subtitle_path_escaped = _escape_ffmpeg_filter_path(str(subtitle_path.absolute()))

    cmd = [
        'ffmpeg',
        '-i', str(video_path),
        '-vf', f"subtitles='{subtitle_path_escaped}'",
        '-c:a', 'copy',
        '-y',
        '-loglevel', 'error',
        str(output_path)
    ]

    result = subprocess.run(cmd, capture_output=True, text=True)

    if result.returncode != 0:
        raise RuntimeError(f"Subtitle embedding failed: {result.stderr}")


def add_subtitle_track(
    video_path: Path,
    subtitle_path: Path,
    output_path: Path,
    language: str = "chi"
) -> None:
    """
    Add subtitle as a track to video (soft subtitles)

    Args:
        video_path: Original video path
        subtitle_path: Subtitle file path
        output_path: Output video path
        language: Subtitle language code (ISO 639-2)
    """
    cmd = [
        'ffmpeg',
        '-i', str(video_path),
        '-i', str(subtitle_path),
        '-c', 'copy',
        '-c:s', 'mov_text',
        '-metadata:s:s:0', f'language={language}',
        '-y',
        '-loglevel', 'error',
        str(output_path)
    ]

    result = subprocess.run(cmd, capture_output=True, text=True)

    if result.returncode != 0:
        raise RuntimeError(f"Failed to add subtitle track: {result.stderr}")


def load_srt(srt_path: Path, bilingual: bool = False) -> List:
    """
    Load an existing SRT file and return segments.

    Args:
        srt_path: Path to the SRT file
        bilingual: If True, treat multi-line as original/translated pair.
                   If False (default), keep all lines as original text.

    Returns:
        List of Segment objects with text (original) and translated fields
    """
    from .transcribe import Segment
    import re

    if not srt_path.exists():
        raise FileNotFoundError(f"SRT file not found: {srt_path}")

    with open(srt_path, 'r', encoding='utf-8') as f:
        content = f.read()

    segments = []

    # Parse SRT format
    # Each entry: index\ntimestamp\ntext\n\n
    blocks = re.split(r'\n\n+', content.strip())

    for block in blocks:
        lines = block.strip().split('\n')
        if len(lines) < 3:
            continue

        # Parse timestamp line: 00:00:01,000 --> 00:00:04,000
        timestamp_match = re.match(
            r'(\d{2}):(\d{2}):(\d{2})[,.](\d{3})\s*-->\s*(\d{2}):(\d{2}):(\d{2})[,.](\d{3})',
            lines[1]
        )
        if not timestamp_match:
            continue

        h1, m1, s1, ms1, h2, m2, s2, ms2 = timestamp_match.groups()
        start = int(h1) * 3600 + int(m1) * 60 + int(s1) + int(ms1) / 1000
        end = int(h2) * 3600 + int(m2) * 60 + int(s2) + int(ms2) / 1000

        # Get text (may be multiple lines)
        text_lines = lines[2:]
        text = '\n'.join(text_lines)

        if bilingual and '\n' in text:
            # For bilingual subtitles, split into original and translated
            # Format: "original\ntranslated"
            parts = text.split('\n', 1)
            original = parts[0]
            translated = parts[1] if len(parts) > 1 else parts[0]
        else:
            # Keep all lines as original text (for source subtitles)
            original = text
            translated = ''

        segments.append(Segment(
            start=start,
            end=end,
            text=original,
            translated=translated
        ))

    return segments
