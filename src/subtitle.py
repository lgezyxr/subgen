"""字幕生成模块"""

import subprocess
from pathlib import Path
from typing import Dict, Any, List
from .transcribe import Segment


def generate_subtitle(
    segments: List[Segment],
    output_path: Path,
    config: Dict[str, Any]
) -> None:
    """
    生成字幕文件
    
    Args:
        segments: 字幕片段列表
        output_path: 输出文件路径
        config: 配置字典
    """
    format_type = config['output']['format']
    bilingual = config['output']['bilingual']
    
    if format_type == 'srt':
        _generate_srt(segments, output_path, bilingual)
    elif format_type == 'ass':
        _generate_ass(segments, output_path, bilingual, config)
    elif format_type == 'vtt':
        _generate_vtt(segments, output_path, bilingual)
    else:
        raise ValueError(f"不支持的字幕格式: {format_type}")


def _format_time_srt(seconds: float) -> str:
    """格式化时间为 SRT 格式 (HH:MM:SS,mmm)"""
    hours = int(seconds // 3600)
    minutes = int((seconds % 3600) // 60)
    secs = int(seconds % 60)
    millis = int((seconds - int(seconds)) * 1000)
    return f"{hours:02d}:{minutes:02d}:{secs:02d},{millis:03d}"


def _format_time_vtt(seconds: float) -> str:
    """格式化时间为 VTT 格式 (HH:MM:SS.mmm)"""
    hours = int(seconds // 3600)
    minutes = int((seconds % 3600) // 60)
    secs = int(seconds % 60)
    millis = int((seconds - int(seconds)) * 1000)
    return f"{hours:02d}:{minutes:02d}:{secs:02d}.{millis:03d}"


def _generate_srt(segments: List[Segment], output_path: Path, bilingual: bool) -> None:
    """生成 SRT 格式字幕"""
    lines = []
    
    for i, seg in enumerate(segments, 1):
        lines.append(str(i))
        lines.append(f"{_format_time_srt(seg.start)} --> {_format_time_srt(seg.end)}")
        
        if bilingual and seg.text:
            # 双语: 译文在上，原文在下
            lines.append(seg.translated)
            lines.append(seg.text)
        else:
            # 单语: 只显示译文
            lines.append(seg.translated or seg.text)
        
        lines.append("")  # 空行分隔
    
    output_path.write_text("\n".join(lines), encoding='utf-8')


def _generate_vtt(segments: List[Segment], output_path: Path, bilingual: bool) -> None:
    """生成 WebVTT 格式字幕"""
    lines = ["WEBVTT", ""]
    
    for i, seg in enumerate(segments, 1):
        lines.append(f"{_format_time_vtt(seg.start)} --> {_format_time_vtt(seg.end)}")
        
        if bilingual and seg.text:
            lines.append(seg.translated)
            lines.append(seg.text)
        else:
            lines.append(seg.translated or seg.text)
        
        lines.append("")
    
    output_path.write_text("\n".join(lines), encoding='utf-8')


def _generate_ass(
    segments: List[Segment],
    output_path: Path,
    bilingual: bool,
    config: Dict[str, Any]
) -> None:
    """生成 ASS 格式字幕（支持样式）"""
    # ASS 头部
    header = """[Script Info]
Title: Generated by SubGen
ScriptType: v4.00+
PlayResX: 1920
PlayResY: 1080
WrapStyle: 0

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,Arial,60,&H00FFFFFF,&H000000FF,&H00000000,&H80000000,0,0,0,0,100,100,0,0,1,3,1,2,10,10,30,1
Style: Secondary,Arial,45,&H00AAAAAA,&H000000FF,&H00000000,&H80000000,0,0,0,0,100,100,0,0,1,2,1,2,10,10,80,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
"""
    
    lines = [header]
    
    for seg in segments:
        start = _format_time_ass(seg.start)
        end = _format_time_ass(seg.end)
        
        if bilingual and seg.text:
            # 双语: 两行
            lines.append(f"Dialogue: 0,{start},{end},Default,,0,0,0,,{seg.translated}")
            lines.append(f"Dialogue: 0,{start},{end},Secondary,,0,0,0,,{seg.text}")
        else:
            lines.append(f"Dialogue: 0,{start},{end},Default,,0,0,0,,{seg.translated or seg.text}")
    
    output_path.write_text("\n".join(lines), encoding='utf-8')


def _format_time_ass(seconds: float) -> str:
    """格式化时间为 ASS 格式 (H:MM:SS.cc)"""
    hours = int(seconds // 3600)
    minutes = int((seconds % 3600) // 60)
    secs = int(seconds % 60)
    centis = int((seconds - int(seconds)) * 100)
    return f"{hours}:{minutes:02d}:{secs:02d}.{centis:02d}"


def embed_subtitle(
    video_path: Path,
    subtitle_path: Path,
    output_path: Path,
    config: Dict[str, Any]
) -> None:
    """
    将字幕烧录进视频
    
    Args:
        video_path: 原视频路径
        subtitle_path: 字幕文件路径
        output_path: 输出视频路径
        config: 配置字典
    """
    # 使用 FFmpeg 烧录字幕
    cmd = [
        'ffmpeg',
        '-i', str(video_path),
        '-vf', f"subtitles={subtitle_path}",
        '-c:a', 'copy',  # 音频直接复制
        '-y',
        str(output_path)
    ]
    
    result = subprocess.run(cmd, capture_output=True, text=True)
    
    if result.returncode != 0:
        raise RuntimeError(f"字幕烧录失败: {result.stderr}")


def add_subtitle_track(
    video_path: Path,
    subtitle_path: Path,
    output_path: Path,
    language: str = "chi"
) -> None:
    """
    将字幕作为轨道添加到视频（软字幕）
    
    Args:
        video_path: 原视频路径
        subtitle_path: 字幕文件路径
        output_path: 输出视频路径
        language: 字幕语言代码
    """
    cmd = [
        'ffmpeg',
        '-i', str(video_path),
        '-i', str(subtitle_path),
        '-c', 'copy',
        '-c:s', 'mov_text',  # 字幕编码
        '-metadata:s:s:0', f'language={language}',
        '-y',
        str(output_path)
    ]
    
    result = subprocess.run(cmd, capture_output=True, text=True)
    
    if result.returncode != 0:
        raise RuntimeError(f"添加字幕轨道失败: {result.stderr}")
